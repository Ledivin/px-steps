<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="css/px-stepper-styles.html">

<!--
### Description

A Polymer component that visualizes step sequences and progress made on them.

### Usage (Declarative)

#### Minimum :

    <px-stepper steps="[[steps]]"></px-stepper>

#### Complete:
    <style id="px-stepper-custom-styles">
    :host {
      --px-stepper-background-color: $white;
    }
    </style>
    <px-stepper
      steps="[[steps]]"
      step-click-event-name="[[stepClickString]]">
    </px-stepper>


### Attributes

#### __steps__

An array that should contain the steps and the details on each.  It has the following structure as demonstrated by this example:

    steps: [
      { id: 1, label: "Basic Information", completed: true},
      { id: 2, label: "Select Services", completed: true},
      { id: 3, label: "Billing", current: true},
      { id: 4, label: "Review"},
      { id: 5, label: "Deploy"}
    ]

In the above structure, for each step object: __"id"__ is a unique identifier, __"label"__ is used as the title
for the step, __"completed"__ indicates if a step is completed, and __"current"__ identifies the current step.  While there is no restriction
against having more than one current step, it is more realistic that there is only one current step, and that all steps to previous to the
current one are completed.  A step is not required to be completed or current; it can be neither.
In the above example, the first 2 steps are complete, Step 3 is current and Step 4 is neither completed nor the current step.

#### __step-click-event-name__

The name of the event that will be dispatched from the browser's __window__ object when a step is clicked on.  When such an
event is dispatched, the Event object will have a __"payload"__ attribute with the following structure:

    Event.payload : {
      "id" : String
    }

In the above, __"id"__ will have the matching id attribute (from the __steps__ array) of the step that was clicked on.
### Styling

The following custom properties are available for styling (shown with their corresponding default values):

--px-stepper-background-color: $gray1;

-->

<dom-module id="px-stepper">

  <template id="pxStepperTemplate">
    <style include="px-stepper-styles"></style>

    <div class="container flex flex--middle">
      <div class="inner-container flex flex--row flex--center flex--top">
        <template id="steps" is="dom-repeat" items="[[steps]]">
          <div class$="step-wrapper [[_getStepState(item)]]">
            <div class="step-connector"></div>
            <div id="step-item-[[item.id]]" class="step-item" on-click="_itemClick">
              <div class="step-icon">
                <px-icon icon="px-nav:[[_getIcon(item)]]"></px-icon>
              </div>
              <div class="step-label">[[item.label]]</div>
            </div>
          <div>
        </template>
      </div>
    </div>

  </template>

  <script>
    Polymer({
      is: 'px-stepper',

      properties: {
        /**
          * The array that contains the steps and details of each.  If empty, the whole component is not rendered at all.
          * The structure should be
          steps: [ { id: Number, label: String, completed: Boolean, current: Boolean}, ... ]
          }.  For each step, if 'completed' is true, the icon whose name is in the 'completedStepIcon' property will be placed
          in the node for the step.  Otherwise if the 'current' is true, the icon whose name is in the 'currentStepIcon' property will be used.
          If both 'completed' and 'current' are false, then no icon will be shown.
          For each step, the 'label' attribute is used for the text underneath the corresponding circle.  */
        steps: {
          type: Array,
          observer: '_onPropertyChange'
        },

        currentStep: {
          type: Number
        },

        /**
          * The name of the event that is dispatched from the browser's 'window' object when a step is clicked on.  The event is populated with a
          * 'payload' object property, with an attribute of 'id' whose value is that of the similarly-named attribute in the corresponding step in
          * the 'steps' property.  The consumer of this component can then define a listener function (attaching it to the browser window as well)
          * to process the event in the desired manner.  If this has an undefined or empty value, no event will be dispatched.
          */
        stepClickEventName: ''
      },


      ready: function() {

      },

      // Helper functions

      complete: function() {
        if ( !this.steps || this.steps.length <= 0 ) {
          console.error("Can't complete step: the steps array is empty or undefined.");
          return;
        }
        // Set current step to complete
        this.steps[this.currentStep].completed = true;

        // Select next step, if there is one
        if ( this.currentStep < this.steps.length-1) {
          this.next();
        }
      },

      next: function() {
        if ( !this.steps || this.steps.length <= 0 ) {
          console.error("Can't select next step: the steps array is empty or undefined.");
          return;
        }
        if ( this.currentStep + 1 > this.steps.length ) {
          console.error("Can't select next step: you are already at the last step.")
        }
        this.jumpToStep( this.currentStep + 1 );
      },

      previous: function() {
        if ( !this.steps || this.steps.length <= 0 ) {
          console.error("Can't select next step: the steps array is empty or undefined.");
          return;
        }
        if ( this.currentStep === 0 ) {
          console.error("Can't select previous step: you are already at the first step.")
          return;
        }
        this.jumpToStep( this.currentStep - 1 );
      },

      jumpToStep: function(step) {
        if ( !this.steps || !this.steps[step] ) {
          console.error("Can't jump to step '" + step + "'; that step doesn't exist.");
          return;
        }
        this.steps[this.currentStep].current = false;
        this.currentStep = step;
        this.steps[this.currentStep].current = true;
        this._onPropertyChange();

        // This is how I get Polymer to register the data change and re-render the steps
        var refresh = this.steps;
        this.steps = [];
        this.steps = refresh;
      },

      _onPropertyChange: function() {
        // If currentStep is not defined, set it based on the array
        if (this.steps && this.steps.length && !this.currentStep) {
          this.currentStep = this._findCurrentStep();
        }

        this.$.steps.render();
        this.updateStyles();
      },

      _findCurrentStep: function() {
        if (!this.steps || this.steps.length <= 0) {
          return -1;
        }
        for(var i = 0; i < this.steps.length; ++i) {
          if( this.steps[i].current ) {
            return i;
          }
        }
        return -1;
      },

      _getIcon: function(item) {
        return (item.completed) ? "confirmed" : "unconfirmed";
      },

      _getStepState: function(item) {
        var classes = '';
        if (item.current) {
          classes += 'current';
        } else if (item.completed) {
          classes += 'complete';
        }
        return classes;
      },

      _itemClick: function(event) {
        if (this.stepClickEventName === undefined || this.stepClickEventName === null || this.stepClickEventName === '') {
          return;
        }
        var stepId = event.currentTarget.id.substr(10);
        var stepClickEvent =
          new Event(this.stepClickEventName,
            {"bubbles": true, "cancelable": false}
          );
        stepClickEvent.payload = { id : stepId };
        window.dispatchEvent(stepClickEvent);
      }

    });
  </script>
</dom-module>
